\chapter{Stand der Technik}
\label{cha:technikstand}
Auf dem Markt gibt es eine Vielzahl von Systemen die eine automatisierte XML Schemagenerierung anbieten.
Als Basis zur Generierung gibt es zum Beispiel bestehende Tabellen einer relationalen Datenbank, oder ein bestehendes XML Dokument mit allen möglichen XML-Elementen. 

\section{XML Schema}
\label{cha:Schema}
XML Schema ist eine Sprache zur Beschreibung von XML Dokumenten. Sie bietet eine Vielzahl von Konstrukten um komplexe Strukturen abbilden zu können und die Integrität eines XML Dokuments sicher zu stellen.

\subsection{Aufbau}
Ein XML Schema wird im XML Syntax geschrieben und ist deswegen gut strukturiert und leicht lesbar.
Neben bereits vordefinierten Datentypen für Text, Zahlen und Datum können auch eigene Datentypen definiert werden. Für die Beschreibung des Datentypen kann das \emph{xsd:attribute}-Element verwendet werden. Diese bietet vordefinierte Typen wie \emph{xsd:integer} und \emph{xsd:string}. Mehr dazu in \cite{Wheeler2011}.

Wie \cite{Madhavan2001} beschreiben, kann man mit mit XSD eigene Datentypen definieren und diese auch in eigenen Namensräumen deklariert werden. Somit kann jeder Datentyp genau identifiziert werden, und es kommt zu keiner Kollision mit den gewählten Bezeichnungen.
Auch sind Lösungen zur Wiederverwendung von bereits definierten Typen vorhanden. Dies ermöglicht eine bessere Wartbarkeit und verhindert Redundanzen und Fehler in den Beschreibungen.

Dabei unterscheidet man die Datentypen in zwei verschiedene Typen:

\begin{enumerate}
\item \textbf{Einfacher Datentyp}: Wird verwendet um Einschränkungen, Kombination oder Listen von definierten Typen zu realisieren. Die Bezeichnung des Elements lautet \emph{simpleType}, siehe Abbildung \ref{fig:simpleTypeExp}.
\item \textbf{Komplexer Datentyp}: Wird verwendet um Sub-Elemente und Attribute zu definieren. Dabei ist auch die Verschachtelung von komplexen Datentypen zulässig. Die Bezeichnung des Elements lautet \emph{complexType}. Siehe Beispiel XML-Datei \ref{fig:complexTypeExp}.
\end{enumerate}

\begin{figure}
\centering
\lstset{
    language=Xml,
    tabsize=3,
    %frame=lines,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{images/simpleType.xml}
\caption{Beispiel für \emph{simpleType}}
\label{fig:simpleTypeExp}
\end{figure}

\begin{figure}
\centering
\lstset{
    language=xml,
    tabsize=3,
    %frame=lines,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{images/complexType.xml}
\caption{Beispiel für \emph{complexType}  
}
\label{fig:complexTypeExp}
\end{figure}

\subsection{Einschränkungen}

\subsection{XML Schema 1.1}
Mit der Version 1.1 des XML Schema sind einige wertvolle Neuerungen dazugekommen. Dazu zählt die Möglichkeit zur Definition von Geschäfts-Regeln. Dies ist ein sehr ähnlicher Funktionsumfang wie bei Schematron, mehr dazu in Kapitel  \ref{cha:Schematron}.
Wie \cite{Walmsley} erläutert können die dafür notwendigen Annotation direkt bei den jeweiligen Typen ergänzt werden.

Als Beispiel dazu angeführt werden:
\begin{enumerate}
\item \textbf{assert}: Mithilfe von XPath-Ausdrücken (siehe Abschnitt \ref{sec:XPath}) können Bedingungen definiert werden, die zusätzlich die Gültigkeit des XML Elements überprüfen. Siehe Beispiel Xml-Datei \ref{fig:AssertExp}
\item \textbf{alternative}: Mit \emph{alternative} kann man eine bedingte Typzuordnung realisieren. Dies ist sinnvoll, wenn zum Beispiel sich der Typ aufgrund eines Wertes in einem XML Attribut ergeben soll. Siehe Beispiel XML-Datei \ref{fig:AlternativeExp}
\end{enumerate}

\begin{figure}
\centering
\lstset{
    language=xml,
    tabsize=3,
    %frame=lines,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{images/assert.xml}
\caption{Beispiel für \emph{assert}  
}
\label{fig:AssertExp}
\end{figure}


\begin{figure}
\centering
\lstset{
    language=xml,
    tabsize=3,
    %frame=lines,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{images/alternative.xml}
\caption{Beispiel für \emph{alternative}  %%\cite{ArtikelExp}.
}
\label{fig:AlternativeExp}
\end{figure}

\section{XML Schematron}
\label{cha:Schematron}
Schematron ist eine Sprache zur Validierung von XML Dokumenten. Sie wurde 1999 von Rick Jeliffe entwickelt.

\subsection{Vorteile}
Mit Schematron ist es möglich, auch Geschäftslogik in einer XML-Datei abzubilden. Wie Lee \cite{Lee2000ComparativeAO} aufzeigt, bietet Schematron einen sehr großes Funktionsumfang der sehr präzise und kompakt definiert werden kann.
Im Vergleich dazu ist es im XML Schema 1.0 nur möglich auf Datentypen, Bereichswerte oder z.B. auf Referenz-Elemente zu überprüfen.

\subsection{Funktionsweise}
Beim Schematron können mehrere 'Business-Rules' definiert werden. Diese spiegeln Regeln wieder die den XML-Baum filtern und überprüfen können. Das dafür definierte XML-Element ist 'rule'. Dabei wird zuerst über einen XPath-Ausdruck der XML-Baum gefiltert. Danach kann auf diesen XML-Elementen über das 'assert'-Element Testfälle abgefragt werden. Entspricht ein XML-Element dem 'assert' Testfall, so wird dazu zugehörige Fehlermeldung dem Benutzer geliefert.
Zu Beachten ist, dass die Filterung der 'rule'-Elemente sich aggregieren und deswegen der Datenbereich immer kleiner wird.
Um wieder vom kompletten XML-Baum zu filtern, muss eine erneute 'Business-Rule' in einem 'pattern'-Element eingeschlossen werden. Mehr dazu in \cite{Montero2011} Kapitel 5.


\subsection{XPath}
\label{sec:XPath}
XPath ist eine Sprache zur Filterung von XML-Dokumenten. Wie in \cite{Kay2011} beschrieben, wird dabei das XML-Dokument in einer Baumstruktur betrachtet. Jedes XML-Element entspricht einer weiteren Verschachtelung innerhalb des Baumes. Mithilfe von definierten Befehlen kann dann in diesem Baum navigiert und gefiltert werden. XPath ist dabei eine mächtige Sprache und unterstützt eine Vielzahl an Funktionen zur Aggregierung, Quantifizierung und Vergleich der Datenelementen. 


\subsection{Validierung}
Da das Schematron mit ISO/IEC 19757-3: \cite{ISO_IEC19757} standardisiert ist, gibt es die Möglichkeit diese in bestehende Strukturen einzugliedern. Wie in \cite{Akhilesh_validatinga} dargestellt, ist es möglich über die XML Elemente \emph{annotation} und \emph{appinfo} die Schematron-Elemente direkt im XML Schema einzubinden.

\section{SQL-Server}
Als Beispiel genauer betrachtet wird hier die Lösung von Microsoft \cite{SqlServer}. Seit SQL Server 2008 unterstützt Microsoft die Generierung von XML Schemata. Dabei ist hier die Generierung nicht auf eine einzige Tabelle beschränkt, sondern kann beliebig über eine SELECT-Statement angegeben werden. 
Mithilfe des Schlüsselwortes FOR XMLSCHEMA wird aufgrund der ausgewählten Spalten im Ergebnis eine Schema generiert.
Dabei ist auch eine Kombination von Schema und des dazugehörigen XML Dokuments möglich.

Mit dem in Programmcode \ref{code:SqlFORSCHEMA} einfachen SQL-Befehl kann ein gültiges XML Schema erstellt werden. Das Ergebnis, siehe Programmcode \ref{code:GeneratedSchemaSql},ist hier ein Schema das sowohl komplexe, als auch einfach definierte Typen beinhaltet.

\begin{program}
\caption{Beispiel eines SQL-Befehls zur Erstellung eines Schemas}
\label{code:SqlFORSCHEMA}
\begin{GenericCode}
    SELECT ARTIKELNR, QTY
    FROM PRODUKT
    FOR XML AUTO, ELEMENTS, XMLSCHEMA
\end{GenericCode}
\end{program}

%\begin{figure}
%    \centering
%    \begin{lstlisting}[
%               language=SQL,
%               showspaces=false,
%               basicstyle=\ttfamily,
%               numbers=left,
%               numberstyle=\tiny,
%               commentstyle=\color{gray}
%            ]
%    SELECT ARTIKELNR, QTY
%    FROM PRODUKT
%    FOR XML AUTO, ELEMENTS, XMLSCHEMA
%    \end{lstlisting}
%    \caption{Beispiel eines SQL-Befehls zur Erstellung eines Schemas}
%    \label{fig:sqlServerExample}
%\end{figure}

\begin{program}
\caption{Generiertes Schema des SQL-Befehls}
\label{code:GeneratedSchemaSql}
\begin{XmlCode}
<xsd:schema targetNamespace="urn:schemas-microsoft-com:sql:SqlRowSet2" 
    xmlns:schema="urn:schemas-microsoft-com:sql:SqlRowSet2"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
    xmlns:sqltypes="http://schemas.microsoft.com/sqlserver/2004/sqltypes" 
    elementFormDefault="qualified">
  <xsd:import namespace="http://schemas.microsoft.com/sqlserver/2004/sqltypes" schemaLocation="http://schemas.microsoft.com/sqlserver/2004/sqltypes/sqltypes.xsd" />
  <xsd:element name="PRODUKT">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="ARTIKELNR" minOccurs="0">
          <xsd:simpleType sqltypes:sqlTypeAlias="[A50]">
            <xsd:restriction base="sqltypes:nvarchar" sqltypes:localeId="1033" sqltypes:sqlCompareOptions="IgnoreCase IgnoreKanaType IgnoreWidth">
              <xsd:maxLength value="50" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:element>
        <xsd:element name="QTY" minOccurs="0">
          <xsd:simpleType>
            <xsd:restriction base="sqltypes:numeric">
              <xsd:totalDigits value="24" />
              <xsd:fractionDigits value="9" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
</xsd:schema>
\end{XmlCode}
\end{program}


\section{Umsetzungen der TU Wien}
Auch bei der Umsetzung einer Magisterarbeit an der TU Wien wurde ein interessanter Lösungsansatz gewählt.
In Zusammenarbeit mit der Krankenanstalt Klagenfurt wurde dabei ein normierter Pflegeentlassungsbericht in einem CDA-System (Clinical Document Architecture) für die elektronische Kommunikation in ein XML Format umgewandelt.
Wagner zeigt in seiner Arbeit \cite{Wagner2007} wie er die Daten klassifiziert und damit ein Datenmodell erzeugt, aus dem schließlich eine XSD-Datei zur Validierung gewonnen werden kann.

\section{X-Database}
Das Datenmodell X-Database von \cite{Varlamis2001BridgingXA} zeigt, dass es mithilfe eines XML-Schemas möglich ist, relationale Datenbanken zu generieren und zu manipulieren. Dabei wurden die Datenbank-Befehle in XML-Elementen aufgeteilt. Sie verwenden dabei simple oder komplexe Typen des XML Schema, um daraus Tabellen zu erstellen, siehe Programmcode \ref{code:XmlToSql}. Dabei werden \emph{attribute} zur Beschreibung der einzelnen Felder genutzt. 

Auch wird mit Hilfe eines XML Schemas die Struktur von Abfragen und Befehlen auf der Datenbank definiert. Wie man im Programmcode \ref{code:SqlFORSCHEMA} sieht, werden Befehle über XML Elemente abgebildet, die zuvor im XML-Schema definiert wurden. Mögliche Befehle sind hier \emph{Insert, Delete, Update} und \emph{Select}.

\begin{program}
\caption{Mapping von XML Schema auf Struktur der Datenbank von\cite{Varlamis2001BridgingXA}}
\label{code:XmlToSql}
\begin{XmlCode}
<xs:complexType name="DigitalStorageDS">
<xs:attribute name="id" type="ID"
use="required"/>
<xs:attribute name="name" type="string"
use="required"/>
</xs:complexType>
\end{XmlCode}
\label{code:ResultingSQL}
\begin{GenericCode}
CREATE TABLE DigitalStorageDS (
id NUMBER NOT NULL,
name VARCHAR2(20) NOT NULL,
PRIMARY KEY (id));
\end{GenericCode}
\end{program}


\begin{program}
\caption{Auszug eines definierten SQL-Befehls von \cite{Varlamis2001BridgingXA}}
\label{code:SqlFORSCHEMA}
\begin{GenericCode}
    <DBCommand>
    <Select where="@-100@ = 1234">
    <from>
        <AudioVisual id="-96" Name="Gladiator"
         AVType="Movie">
            <MediaInfo id="-97">
            <MediaProfile>
            <MediumRef>-100</MediumRef>
            </MediaProfile>
            </MediaInfo>
        </AudioVisual>
    </from>
    <return>
    <AudioVisualRef>-98</AudioVisualRef>
    </return>
    </Select>
    </DBCommand>
\end{GenericCode}
\end{program}

\section{Gegenüberstellung}
Der Datenaufbau bei \BMD ist für den SQL Server oder ähnlichen Produkten zu komplex.
Die Einträge in den Tabellen könnten zwar so manipuliert werden, dass diese einer Spalte in dem Ergebnis widerspiegeln, jedoch würde der Datentyp nicht zu dem jeweiligen Feld passen. Hier liegen mehrere Tabellen im Hintergrund, die den Datentypen, die Bereichswerte und die Darstellung im Programm widerspiegeln. 
Gleichzeitig wäre eine explizite Anpassung an mehrere Datenbanksystemen notwendig, da \BMD sowohl Microsoft SQL Server, als auch Oracle unterstützt.